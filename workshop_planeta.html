<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <title>3D Earth with Space Station</title>
    <style>


        body { margin: 0; overflow: hidden; background-color: black; }
        canvas { display: block; }
        /* Style for the station button/link, even though the click is handled with JS */
        #stationLink {
            position: absolute;
            z-index: 1000;
            cursor: pointer;
            color: white;
            padding: 5px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 5px;
            display: none; /* Will be shown and positioned with JS */
            text-decoration: none;
            font-family: sans-serif;
            font-size: 14px;
        }
    </style>

    <script type="importmap">
        {
          "imports": {
            "three": "https://unpkg.com/three@0.157.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.157.0/examples/jsm/"
          }
        }
    </script>
</head>
<body>
    <div id="container"></div>
    <a id="stationLink" href="https://view.genially.com/68e223ab2111e7703638a51d/interactive-content-iss" target="_blank" onclick="console.log('Navigating to the station page...')">Space Station</a>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // --- Initial Setup ---
        const container = document.getElementById('container');
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000000); // Black background

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 0, 5);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        container.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true; // Enables smoother camera movement

        // --- Lights ---
        // Ambient light to illuminate dark parts
        scene.add(new THREE.AmbientLight(0x404040, 3)); 
        // Directional light to simulate the Sun
        const sunLight = new THREE.DirectionalLight(0xffffff, 4);
        sunLight.position.set(5, 5, 5);
        scene.add(sunLight);

        // --- Earth Creation ---
        const EARTH_RADIUS = 1.5;
        const loader = new THREE.TextureLoader();
        
        // Textures (using example direct links to simplify, ideally use your own textures)
        const earthTexture = loader.load('https://wallpapers.com/images/high/real-earth-world-map-s9s5vx1eupas9euj.jpg');
        const earthBumpMap = loader.load('https://unpkg.com/three@0.157.0/examples/textures/planets/earth_normal_2048.jpg');
        const earthSpecularMap = loader.load('https://unpkg.com/three@0.157.0/examples/textures/planets/earth_specular_2048.jpg');
        
        const earthGeometry = new THREE.SphereGeometry(EARTH_RADIUS, 64, 64);
        const earthMaterial = new THREE.MeshPhongMaterial({
            map: earthTexture,
            bumpMap: earthBumpMap,
            bumpScale: 0.05,
            specularMap: earthSpecularMap,
            specular: new THREE.Color('grey'),
            shininess: 10,
        });
        const earth = new THREE.Mesh(earthGeometry, earthMaterial);
        scene.add(earth);


        const STATION_ORBIT_RADIUS = EARTH_RADIUS + 0.8; // Orbit radius
        const stationGeometry = new THREE.BoxGeometry(0.3, 0.1, 0.1); // Rectangular shape

        
        const stationTexture = loader.load('https://upload.wikimedia.org/wikipedia/commons/thumb/e/e1/The_station_pictured_from_the_SpaceX_Crew_Dragon_5_%28cropped%29.jpg/500px-The_station_pictured_from_the_SpaceX_Crew_Dragon_5_%28cropped%29.jpg'); 


        const stationMaterial = new THREE.MeshStandardMaterial({ 
            map: stationTexture, // <-- APPLY THE TEXTURE HERE
            metalness: 0.8, 
            roughness: 0.2 
        });

        const station = new THREE.Mesh(stationGeometry, stationMaterial);

        
        // The station mesh is added to the orbital group, not directly to the scene
        const orbitGroup = new THREE.Group();
        orbitGroup.add(station);
        scene.add(orbitGroup);

        // Position the initial station
        station.position.set(STATION_ORBIT_RADIUS, 0, 0);

        // --- Link Functionality and Raycasting ---
        const stationLinkElement = document.getElementById('stationLink');
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        renderer.domElement.addEventListener('mousemove', onMouseMove, false);
        renderer.domElement.addEventListener('click', onCanvasClick, false);

        function onMouseMove(event) {
            // Normalize the mouse position to device coordinates (-1 to +1)
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;

            // Cast the ray from the camera position
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObject(station);

            if (intersects.length > 0) {
                // Intersection found: Show and position the HTML element
                const vector = new THREE.Vector3().setFromMatrixPosition(station.matrixWorld);
                vector.project(camera); // Project the 3D position to 2D screen coordinates

                // Calculate pixel coordinates
                const x = (vector.x * .5 + .5) * window.innerWidth;
                const y = (vector.y * -.5 + .5) * window.innerHeight;

                stationLinkElement.style.display = 'block';
                // Adjustment to center the HTML element
                stationLinkElement.style.left = `${x - stationLinkElement.offsetWidth / 2}px`;
                stationLinkElement.style.top = `${y - stationLinkElement.offsetHeight / 2}px`;
                renderer.domElement.style.cursor = 'pointer';

            } else {
                // No intersection: Hide the HTML element and restore the cursor
                stationLinkElement.style.display = 'none';
                renderer.domElement.style.cursor = 'auto';
            }
        }

        function onCanvasClick(event) {
             // This is mainly done to prevent OrbitControls from dragging the camera when clicking to navigate
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObject(station);
            
            if (intersects.length > 0) {
                // Prevent OrbitControls from processing the click for dragging
                event.stopPropagation(); 
                // Simulate the click on the 'a' element to navigate
                window.open(stationLinkElement.href, stationLinkElement.target);
            }
        }

        // --- Animation ---
        const orbitSpeed = 0.5; // Orbital rotation speed (in radians per second)
        const earthRotationSpeed = 0.1; // Earth's self-rotation speed

        function animate(time) {
            requestAnimationFrame(animate);

            // 1. Earth's rotation on its own axis
            earth.rotation.y += earthRotationSpeed * 0.01;

            // 2. Station's Orbital Movement (rotating the group around the origin)
            orbitGroup.rotation.y += orbitSpeed * 0.01;
            
            controls.update();
            renderer.render(scene, camera);
        }

        animate();

        // --- Resize Handling ---
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

    </script>
</body>
</html>